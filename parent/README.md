This project contains tools for evaluating proposed algorithms for dispatching call requests to a group of elevators in an online fashion.  The "online" designation allows the algorithm only a small margin of time between receiving a call request and allocating it a resource for service.  Candidate implementations can fail the assessment by either failing to return dispatch responses in the "online" time window or by producing poor performance in terms of the time it takes passengers to reach their destinations.  `

High Level Overview

This project contains software for bootstrapping a closed model simulation with passengers and elevators.  Passengers
enter the simulation by pressing a call button to indicate their desired direction of travel.  The dispatch strategy is
invoked and assigns a car to travel to the pickup landing.  The passenger then rides to his or her destination floor and
the simulation makes a note of the virtual clock time at that moment.  

Preparing a simulation typically involves three distinct activities.  Steps one and two boil down to configuration in most cases by reusing implementation classes from the framework's own code base.  One of these models the passenger population's rate of arrival at each landing and a probability distribution for each arriva's intended destination.  The second involves modeling operational qualities of the elevators themselves, such as maximum speeds and accelerations, braking distances, and door hold times.  The built-in classes that use these models create adapters for the elevator SDK's event emitter API and use the model state to parameterize their behavior patterns.

The third activity involes selecting or implementing an elevator dispatch strategy and providing its implementation for wiring into the test harness.  

Another defines operational variables of the elevator mechanism, such as its top speed, maximum acceleration,
and door cycle duration.  These models correspond to built-in strategies provided by the framework that are provided an interface for emitting events that report changes in the state of an elevator car, passenger, or landing control.  The former is used to schedule passengers entering the simulation spread out to be consistent with the population model's prescribed distribution.  The latter is used to inform the simulation about how each elevator car responds to everythng that has heppened so far (e.g. passengers on board, pickup calls assigned, etc.)

Getting Started

We have an integration with Spring Boot that automates much of the wiring for the first two steps described above and includes a convention for acquiring the configuration state models for passengers and elevator cars from properties in
an application.properties file.

It begins with a simple Spring Boot application.  Next, add  an instance of                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Add the @EnableElevatorDispatchSimulator annotation.


Inputs provided to the software by a simulation modeler include:
-- An instance of a passenger population model whose constituents drive the simulated elevator's workload during each simularion executed with it as input.
   -- Each class is defined in terms of a random variable distribtuion for rate of arrival, and a minimum of two probability distribution functions that define floor of arrival and intended destination.
   -- Simulation modelers may also use provided SDK to substitute the built-in classifier-based user population model with any other implementation that can be used derive a stream of values where each value a triplet consisting of an arrival timestamp, an arrival floor index, and a destination floor index.

-- An instance of a model describing its elevator's operational constraints and environment.  This includes information that drives the physics engine for elevator movements, such as maximum speeds, and limits on weight capacity.  It also includes policy information, such as the number of floors and elevators present, the minimum time each car needs to open and close its doors, and the time it will wait without someone crossing its threshold before returning to service.
   -- The information in this model is made accessibly to both the elevator emulator and the strategy object for the dispatcher under test.
      -- In the former case, the metadata is used to configure the physics engine that provides information about how the elevator responds to the combination of passenger activity and dispatching signals from the scheduling strategy in use.
      -- In the latter case, the information is provided because it consists of information that would reasonably be available a priori, unlike information generated at runtime, such as true passenger destinations, that the simulation does not share with the dispatcher under test.

-- An set of injected software dependencies that provide provide the simulation with concrete implementations of a handful of interfaces.  The first three of these four artifacts will typically be implementations chosen by the simulation modeler, but implemented as a part of this project.  The project will also include example scheduling algorithms that can be used to provide the last argument as well, but wheras the bundled options for the first three are provided for "real world" application, implementations of the scheduling aalgorithm are only provided as teaching examples for developers creating new ones to test.
	-- A clock interface implementation that it will provide a frame of reference for time to the emulated elevator and its passengers.
	-- A driver factory that will be used to adapt its elevator state model for each car and serve as a source of event information about the each elevator.  The built-in implementaiton will commonly be used and is where the projet's physics engine generates the behavior result for each elevator.
	   -- If combined with a realtime scheduler, a simulation modeler could, in theory, replace the emulated elevator model with a more tangible mechanical entity, and would therefore need to replace the driver factory to provide the necessary hardware/software interface.
       -- A "director function" that will be called with a reference to the user population model and a strategy interface.  The interface was previously discussed in terms of an SDK for customizing the model for passenger arrival and destination selection.  There is a built-in implementation that is compatible with thesimple built-in classification model for passenger population metadta.
          -- The term "Director" is a reference to a functional role from the "Builder Design Pattern" characterized by the fact that it is provided a Builder with the expectation that it will use the Builder to describe a desired constructed artifact.  In this case, concept under construction is the population of elevator passengers.  The interface is therefore oriented towards collecting the tripples of "arrival time", "arrival floor", and "destination floor", where timestamps in question are relative to the first virtual clock argument's notion of time.
       -- A strategy function that implements the scheduler algorithm under consideration.

Methodology

This project is primarily concerned with providing a virtual model of an elevator that undergoes state changes according to a simulated clock that can be made to tick forward through simulation time at a rate that is independent of the actual passage of time from an observer's frame of reference.  The end goal is to collect data about the performance of candidate scheduling algorithms as efficiently as possible without compromising the information gathered.  Being able to control the passage of time relative to entities that are "inside" the simulation makes it possible to provide the schedule with a day's worth of stimulus in far less than that much time.

If throughput was our only concern, we could probably stop there and just use our simulation to create bulk batches of input test data to examine offline.  
Throughput is not the only                                                                                                                                                                                                                                                                                                                                                                                                                                                                               aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaawwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww

 event clock up to run the simulation's virtual clock forward fast than our own real-time clock, we also need an ability to pause the simulation clock and let the dispatcher catch up.  We cannot accelerate the dispatcher's operation the same way as the simulation's data-generating actors because we cannot raise the scheduler's level of abstraction the same way as we can the virtual elevators and passengers.  We can only raise the level of abstraction on the known quantites in this kind of experiment.

That does not mean we can get away with being completely ignorant of some concept of time when running the scheduler.  The elevator dispatch problem is an online task.  When a passenger presses the call button at some landing, and the dispatcher receives notification that a decision is required, the scheduler may be able to get away with not answering immediately, but since elevators are still in motion and the passenger's tolerance for waiting will gradually diminish, the dispatcher cannot afford the luxury of a solution that yields high throughput at high latency.  Consider the extreme example of a bulk job dispatcher that accurately picks the best car for every passenger over the course of a 24 hour period, but can only produce a bulk report once evey 24 hours.  Unless we place some form of time constraints on the dispatcher's behavior, we run the risk of compromoising our experiment by utilizing a virtual clock to drive the simulation's generated behavior.


 has been designed primarily for use cases involving a virtual elevator, as this is the most practical context for the feasability and evaluation stage of a building's construction timeline.  Operation in a simulated environment necessitates a virtual concept of time.  Instead of measuring the durations of events with an actual timer, simulations generally have an abstraction in their model that represents time, and they often are capable of computing a sequence of simulation event with sufficient efficiency that each unit of elapsed CPU time maps to a considerably longer duration in terms of simulation results.

Although our primary objective is to satisfy an elevator control system simulation's need to virualize time, we have also set a design objective to not leak aspects of this virtualization into the implemtnation in ways that would compromise its ability to support experiments with real-time control scenarios as well as virualized ones.  Providing an interface that could be sastisfied with either a native-backed implementation or a virtually-controlled implementation provides a valuable measure of flexiblity 

It is undesirable to implement support for these simulations using the operating system's native API for the system clock, as we cannot manipulte system time to the extent required here, any more than we can we exert software control over the flow of time as perceived by the end user.  The ideal API to present to actors that are part of the simulation environment should provide the same developer experience as the native API.  There will undoubtedtly be additional controls provided for observers outside of the simulation container.  Those extra interface elements will allow a developper to control the the relative difference between the passage of simulation time versus time in our own frame of reference.

For a more concrete example, consider the effects of calling two common clock use cases, a sleep() function that defers a thread's execution flow until a specified future time point, and a now() function that returns a "current" value from a monotonically increasing sequence that effectively maps each discrete moment in time to a unique numeric value.  In order for a virtual implementation of these methods to be correct, the value returned by now() after a return from sleep() should reflect the requests passage of time.  Further more, the simulation environment the clock and the thread just resumed are participants of will need to have undergone an appropriate amount of state changes to account for the requested passage of time.  If that system were to include, for example, and elevator moving between floors, then the state of the software model for that elevator will have to reflect an appropriate amount of displacement for the whatever interval of time the observing thread was allegedly blocked in sleep().


The Virtual Elevator

There is no way to get around the need for a simulated elevator to have access to some abstraction representing time.  Unlike its realworld counterpart, a virtual elevator cannot rely physical components to provide trigger its logic.  In the absence of real hardware interrupts, we have to resort to software-emulation of external triggers, and that requires some ability to quantify time.

The most obvious use case for virtual time from the perspective of a software model of an elevator occurs when we need to model the time an elevator spends travelling from floor to floor.  The second occurence involves the time spent loading and unloading passengers, which is of relevance here because a control system must account for its inability to endanger the safety of passengers by moving the elevator to another floor while the landing doors are open and actively in use.

While contemplating how to address the passage of time, it is also a good time to consider concurrency 

 The implementation design has made several choices about its decomposition and separation of concerns 


1) Passengers arrive and call
2) Scheduler sends dispatches
